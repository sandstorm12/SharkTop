#!/usr/bin/python3

# Based on example by https://gist.github.com/claymcleod


import os
import re
import sys
import time
import signal
import curses
import argparse
import threading
import subprocess


start_time = None
close = False
args = None
framerate = {}


def _update_values(process):
    for line in iter(process.stdout.readline, ""):
        search = re.search(
            (
                r"(.*)(framerate)(.*)(pad=\(string\))"
                r"(.*)(,)(.*)(fps=\(uint\))(\d+)"
            ),
            line.decode("utf-8")
        )

        if search is not None:
            if search.group(2) == "framerate":
                framerate[search.group(5)] = search.group(9)


def _get_arguments():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        '-r', '--referesh_rate',
        help='Update rate per second',
        type=int,
        default=2
    )
    parser.add_argument(
        'pipeline', metavar='Pipeline discription',
        type=str, nargs='+',
        help='Command to run GStreamer pipeline'
    )
    args = parser.parse_args()

    return args


def draw_menu(stdscr):
    global close
    global args

    k = 0
    cursor_x = 0
    cursor_y = 3
    cursor_y_content = 0

    # Clear and refresh the screen for a blank canvas
    stdscr.clear()
    stdscr.refresh()

    # Start colors in curses
    curses.start_color()
    curses.init_pair(1, curses.COLOR_CYAN, curses.COLOR_WHITE)
    curses.init_pair(2, curses.COLOR_BLUE, curses.COLOR_BLACK)
    curses.init_pair(3, curses.COLOR_BLACK, curses.COLOR_WHITE)
    curses.init_pair(4, curses.COLOR_RED, curses.COLOR_YELLOW)

    # Loop where k is the last character pressed
    while (k != ord('q')):
        # Initialization
        stdscr.clear()
        height, width = stdscr.getmaxyx()

        if k == curses.KEY_DOWN:
            cursor_y_content = min(
                len(framerate.keys()), max(0, cursor_y_content + 1)
            )
            cursor_y = min(height - 2, max(3, cursor_y + 1))
        elif k == curses.KEY_UP:
            cursor_y_content = min(
                len(framerate.keys()), max(0, cursor_y_content - 1)
            )
            if cursor_y_content <= height - 4:
                cursor_y = min(height - 2, max(3, cursor_y - 1))
        elif k == curses.KEY_RIGHT:
            cursor_x = min(width - 1, max(0, cursor_x + 1))
        elif k == curses.KEY_LEFT:
            cursor_x = min(width - 1, max(0, cursor_x - 1))

        # Render title
        stdscr.attron(curses.color_pair(4))
        stdscr.addstr(0, 0, "Pipeline:")
        stdscr.addstr(0, 9, " " + " ".join(args.pipeline)[:width - 10])
        stdscr.attroff(curses.color_pair(4))

        # Render headers
        stdscr.attron(curses.color_pair(1))
        stdscr.addstr(2, 0, "Element" + (" " * (width // 2 - 7)))
        stdscr.addstr(
            2, width // 2,
            "Framerate" + (" " * (width // 2 - 9))
        )
        stdscr.attroff(curses.color_pair(1))

        # Render values
        stdscr.attron(curses.color_pair(2))

        offset = max(cursor_y_content - height + 4 + 1, 0)
        keys = list(framerate.keys())
        for i in range(3, min(height, len(keys) - offset + 3)):
            print(len(keys), offset)
            key = keys[i - 3 + offset]

            if i == cursor_y:
                stdscr.attroff(curses.color_pair(2))
                stdscr.attron(curses.color_pair(1))

            stdscr.addstr(i, 0, key + (" " * (width // 2 - len(key))))
            stdscr.addstr(
                i, width // 2,
                str(framerate[key]) +
                (" " * (width // 2 - len(str(framerate[key])) - 1))
            )

            if i == cursor_y:
                stdscr.attroff(curses.color_pair(1))
                stdscr.attron(curses.color_pair(2))

        stdscr.attroff(curses.color_pair(2))

        # Render status bar
        statusbarstr = "Press 'q' to exit | runtime: {:.2f}s".format(
            time.time() - start_time
        )
        stdscr.attron(curses.color_pair(3))
        stdscr.addstr(height-1, 0, statusbarstr)
        stdscr.addstr(
            height-1, len(statusbarstr),
            " " * (width - len(statusbarstr) - 1)
        )
        stdscr.attroff(curses.color_pair(3))

        # Move curser
        stdscr.move(cursor_y, cursor_x)

        # Refresh the screen
        stdscr.refresh()

        # Wait for next input
        stdscr.timeout(int(min(1 / args.referesh_rate, .5) * 10e2))
        k = stdscr.getch()
        time.sleep(1 / 60)

    close = True


def _initialize_update_thread(process, args):
    thread = threading.Thread(
        target=_update_values,
        args=(process,)
    )
    thread.daemon = True
    thread.start()


def _run_command(args):
    global start_time

    env = os.environ.copy()
    env["GST_DEBUG"] = "GST_TRACER:7"
    env["GST_TRACERS"] = "framerate"
    process = subprocess.Popen(
        args.pipeline, stdout=subprocess.PIPE, env=env,
        stderr=subprocess.STDOUT
    )

    start_time = time.time()

    return process


if __name__ == "__main__":
    args = _get_arguments()

    process = _run_command(args)

    _initialize_update_thread(process, args)

    curses.wrapper(draw_menu)

    process.kill()
